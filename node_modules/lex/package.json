{
  "name": "lex",
  "description": "An elegant armor-plated JavaScript lexer modelled after flex. Easily extensible to tailor to your need for perfection.",
  "version": "1.7.5",
  "keywords": [
    "lex",
    "lexer",
    "lexical",
    "analysis",
    "scan",
    "scanner",
    "scanning",
    "token",
    "tokenize",
    "tokenizer",
    "tokenization",
    "flex",
    "jison"
  ],
  "author": {
    "name": "Aadit M Shah",
    "email": "aaditmshah@fastmail.fm",
    "url": "http://aaditmshah.github.com/"
  },
  "main": "lexer.js",
  "maintainers": [
    {
      "name": "Aadit M Shah",
      "email": "aaditmshah@fastmail.fm",
      "url": "http://aaditmshah.github.com/"
    }
  ],
  "contributors": [
    {
      "name": "Aadit M Shah",
      "email": "aaditmshah@fastmail.fm",
      "url": "http://aaditmshah.github.com/"
    }
  ],
  "bugs": {
    "url": "https://github.com/aaditmshah/lexer/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  ],
  "repositories": [
    {
      "type": "git",
      "url": "https://github.com/aaditmshah/lexer.git"
    }
  ],
  "dependencies": {},
  "homepage": "https://github.com/aaditmshah/lexer",
  "readme": "# Lexer #\n\nAn elegant armor-plated JavaScript lexer modelled after flex. Easily extensible to tailor to your need for perfection.\n\n## Installation ##\n\nLexer may be installed on [node.js](http://nodejs.org/ \"node.js\") via the [node package manager](https://npmjs.org/ \"npm\") using the command `npm install lex`.\n\nYou may also install it on [RingoJS](http://ringojs.org/ \"Home - RingoJS\") using the command `ringo-admin install aaditmshah/lexer`.\n\nYou may install it as a [component](https://github.com/component/component \"component/component\") for web apps using the command `component install aaditmshah/lexer`.\n\n## Usage ##\n\nCreating a lexer is as simple as instantiating the constructor `Lexer`.\n\n```javascript\nvar lexer = new Lexer;\n```\n\nAfter creating a lexer you may add rules to the lexer using the method `addRule`. The first argument to the function must be a `RegExp` object (the pattern to match). The second argument must be a function (the action to call when the pattern matches some text). The arguments passed to the function are the lexeme that was matched and all the substrings matched by parentheticals in the regular expression if any.\n\n```javascript\nvar lexer = new Lexer;\n\nlexer.addRule(/[a-f\\d]+/i, function (lexeme) {\n    return \"HEX\";\n});\n```\n\nAfter adding rules to the lexer you may set the property `input` of the lexer to any string that you wish to tokenize and then call the method `lex`. The function returns the first non `undefined` value returned by an action. Else it returns `undefined` if it scans the entire input string. On calling `lex` it starts scanning where it last left off. The `addRule` and `setInput` methods of the lexer support chaining.\n\n```javascript\nvar lines = 0;\nvar chars = 0;\n\n(new Lexer).addRule(/\\n/, function () {\n    lines++;\n    chars++;\n}).addRule(/./, function () {\n    chars++;\n}).setInput(\"Hello World!\").lex();\n```\n\nIf the lexer can't match any pattern then it executes the default rule which matches the next character in the input string. The default action may be specified as an argument to the constructor. Setting the property `reject` on the `this` object in an action to `true` tells the lexer to reject the current rule and match the next best rule.\n\n```javascript\nvar row = 1;\nvar col = 1;\n\nvar lexer = new Lexer(function (char) {\n    throw new Error(\"Unexpected character at row \" + row + \", col \" + col + \": \" + char);\n});\n\nlexer.addRule(/\\n/, function () {\n    row++;\n    col = 1;\n}, []);\n\nlexer.addRule(/./, function () {\n    this.reject = true;\n    col++;\n}, []);\n\nlexer.input = \"Hello World!\";\n\nlexer.lex();\n```\n\nYou may even specify [start conditions](http://flex.sourceforge.net/manual/Start-Conditions.html \"Start Conditions - Lexical Analysis With Flex, for Flex 2.5.37\") for every rule as an optional third argument to the `addRule` method (which must be an array of unsigned integers). By default all rules are active in the initial state (i.e. `0`). Odd start conditions are inclusive while even start conditions are exclusive. Rules with an empty array as the third argument are always active.\n\n## Integration with Jison ##\n\nThe generated lexer may be used as a custom scanner for Jison. Actions must return tokens and associated text must be made available in the property `yytext` on the object `this` from within the action.\n\n```javascript\nvar Parser = require(\"jison\").Parser;\nvar Lexer = require(\"lex\");\n\nvar grammar = {\n    \"bnf\": {\n        \"expression\" :[[ \"e EOF\",   \"return $1;\"  ]],\n        \"e\" :[[ \"NUMBER\",  \"$$ = Number(yytext);\" ]]\n    }\n};\n\nvar parser = new Parser(grammar);\nvar lexer = parser.lexer = new Lexer;\n\nlexer.addRule(/\\s+/, function () {});\n\nlexer.addRule(/[0-9]+(?:\\.[0-9]+)?\\b/, function (lexeme) {\n    this.yytext = lexeme;\n    return \"NUMBER\";\n});\n\nlexer.addRule(/$/, function () {\n    return \"EOF\";\n});\n\nparser.parse(\"2\");\n```\n\nStarting from v1.6.0 you can return multiple values from an action by returning an array. The elements of the array will be returned individually by the `lex` method. This allows you to implement features like [python style indentation](http://docs.python.org/release/2.5.1/ref/indentation.html \"2.1.8 Indentation\") as follows:\n\n```javascript\nvar indent = [0];\n\nvar lexer = new Lexer;\n\nlexer.addRule(/^[\\t ]*/, function (lexeme) {\n    var indentation = lexeme.length;\n\n    if (indentation > indent[0]) {\n        indent.unshift(indentation);\n        return \"INDENT\";\n    }\n\n    var tokens = [];\n\n    while (indentation < indent[0]) {\n        tokens.push(\"DEDENT\");\n        indent.shift();\n    }\n\n    if (tokens.length) return tokens;\n});\n```\n\n## Global Patterns ##\n\nSometimes you may wish to match a pattern which need not necessarily generate the longest possible string. Since the scanner sorts the matched strings according to their length there's no way to do so. Hence in v1.7.0 I introduced global patterns. Strings matching these patterns are never sorted. This allows you to match a shorter strings before longer ones:\n\n```javascript\nvar lexer = new Lexer;\n\nlexer.addRule(/^ */gm, function (lexeme) {\n    console.log(lexeme.length);\n});\n\nlexer.addRule(/[0-9]+/, function (lexeme) {\n    console.log(lexeme);\n});\n\nlexer.setInput(\"37\");\n\nlexer.lex();\n```\n\nThe above program first logs the number of spaces at the beginning of the line (`0`) and then the number `37` although the length of the string `\"37\"` is greater than the empty string `\"\"`. This is because it's the first rule and the `global` flag for its pattern is set.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "https://github.com/aaditmshah/lexer.git"
  },
  "_id": "lex@1.7.5",
  "_from": "lex@latest"
}
